#if 1
typedef int            DLB_fract32;  /*!< 32-bit fractional data (Q31) */
typedef int            DLB_int32;    /*!< 32-bit signed integer */
typedef short          DLB_int16;    /*!< 16-bit signed integer */
typedef unsigned short DLB_uint16;   /*!< 16-bit unsigned integer */
typedef unsigned int   DLB_uint32;   /*!< 32-bit unsigned integer */
typedef short                   DSPshort;   /*!< DSP integer */
/*! \brief Window-Overlap-Add module PCM pointer structure */
typedef struct
{
    DLB_fract32 *p_pcmbuf;    /*!< Pointer to PCM buffer */
    DSPshort chanoffset;   /*!< Channel offset */
    DSPshort modulo;       /*!< Modulo value */
} WOAD_PCMPTRS;

#define DSPrnd(a,b,c)   (c)             /* null function */
#define     ERR_CHKARG(a)   
#define     ERR_CHKRTN(a)   

#define FLOAT_INT32_ONE       2147483648.0
#define FLOAT_INT16_ONE            32768.0

#define DLB_INT32_MAX          ((DLB_int32)0x7fffffff)
  /* necessary to suppress 'unary minus operator' in WIN32 */
#define DLB_INT32_MIN          (0-0x80000000)
#define DLB_INT16_MAX          ((DLB_int16)0x7fff)
#define DLB_INT16_MIN          ((DLB_int16)-0x8000)
#define DLB_INT_MIN    DLB_INT32_MIN
#define DLB_INT_MAX    DLB_INT32_MAX

#define FRACT(x)      INT32(x)
#define INT32(x) ( (x) >= 0.0 ? \
  ((x)*FLOAT_INT32_ONE+0.5 <   FLOAT_INT32_ONE ? (DLB_int32)((x)*FLOAT_INT32_ONE+0.5) : (DLB_int32)DLB_INT32_MAX ) : \
  ((x)*FLOAT_INT32_ONE-0.5 >= -FLOAT_INT32_ONE ? (DLB_int32)((x)*FLOAT_INT32_ONE-0.5) : (DLB_int32)DLB_INT32_MIN ))
#define     GBL_BLKSIZE             256     /*!< Block length (half transform length) */
#define     GBL_FFTSIZE             128     /*!< FFT transform size */
#define     GBL_FFTSIZELG2M3        4       /*!< log2(GBL_FFTSIZE) - 3 */
#define     GBL_MAXMANTS            253     /*!< Maximum number of mantissas per channel */
#define     GBL_LFEMANTS            7       /*!< Number of LFE mantissas */
#define     GBL_PERCENT2FRACT_FACTOR        10737418  /* 0x40000000/100 */
#define     GBL_PERCENT2FRACT_MAP(a)        ((DLB_fract32)(a) * (GBL_PERCENT2FRACT_FACTOR))


#define     XFMD_BIT_SHIFT  2


/*! Half-block-size cosine array */
DLB_fract32 zcos1[GBL_BLKSIZE/2] =
{   FRACT(-0.99999882345170190000), FRACT(-0.99990470108285290000),
    FRACT(-0.99965999674395920000), FRACT(-0.99926474728659440000),
    FRACT(-0.99871901223387290000), FRACT(-0.99802287377148620000),
    FRACT(-0.99717643673532620000), FRACT(-0.99617982859569700000),
    FRACT(-0.99503319943811860000), FRACT(-0.99373672194072460000),
    FRACT(-0.99229059134825740000), FRACT(-0.99069502544266460000),
    FRACT(-0.98895026451030300000), FRACT(-0.98705657130575100000),
    FRACT(-0.98501423101223980000), FRACT(-0.98282355119870520000),
    FRACT(-0.98048486177346940000), FRACT(-0.97799851493455710000),
    FRACT(-0.97536488511665700000), FRACT(-0.97258436893473220000),
    FRACT(-0.96965738512429240000), FRACT(-0.96658437447833310000),
    FRACT(-0.96336579978095400000), FRACT(-0.96000214573766600000),
    FRACT(-0.95649391890239510000), FRACT(-0.95284164760119870000),
    FRACT(-0.94904588185270060000), FRACT(-0.94510719328526060000),
    FRACT(-0.94102617505088930000), FRACT(-0.93680344173592160000),
    FRACT(-0.93243962926846240000), FRACT(-0.92793539482261790000),
    FRACT(-0.92329141671952760000), FRACT(-0.91850839432521230000),
    FRACT(-0.91358704794525080000), FRACT(-0.90852811871630610000),
    FRACT(-0.90333236849451180000), FRACT(-0.89800057974073990000),
    FRACT(-0.89253355540276460000), FRACT(-0.88693211879434220000),
    FRACT(-0.88119711347122210000), FRACT(-0.87532940310411090000),
    FRACT(-0.86932987134860680000), FRACT(-0.86319942171212420000),
    FRACT(-0.85693897741782880000), FRACT(-0.85054948126560350000),
    FRACT(-0.84403189549006640000), FRACT(-0.83738720161566190000),
    FRACT(-0.83061640030884630000), FRACT(-0.82372051122739140000),
    FRACT(-0.81670057286682780000), FRACT(-0.80955764240405130000),
    FRACT(-0.80229279553811570000), FRACT(-0.79490712632823700000),
    FRACT(-0.78740174702903140000), FRACT(-0.77977778792301460000),
    FRACT(-0.77203639715038450000), FRACT(-0.76417874053611670000),
    FRACT(-0.75620600141439450000), FRACT(-0.74811938045040360000),
    FRACT(-0.73992009545951620000), FRACT(-0.73160938122389260000),
    FRACT(-0.72318848930652750000), FRACT(-0.71465868786276910000),
    FRACT(-0.70602126144933970000), FRACT(-0.69727751083088660000),
    FRACT(-0.68842875278409050000), FRACT(-0.67947631989936510000),
    FRACT(-0.67042156038017310000), FRACT(-0.66126583783999230000),
    FRACT(-0.65201053109695950000), FRACT(-0.64265703396622690000),
    FRACT(-0.63320675505005720000), FRACT(-0.62366111752569460000),
    FRACT(-0.61402155893103850000), FRACT(-0.60428953094815610000),
    FRACT(-0.59446649918466450000), FRACT(-0.58455394295301530000),
    FRACT(-0.57455335504771580000), FRACT(-0.56446624152051950000),
    FRACT(-0.55429412145362010000), FRACT(-0.54403852673088390000),
    FRACT(-0.53370100180715300000), FRACT(-0.52328310347565640000),
    FRACT(-0.51278640063356310000), FRACT(-0.50221247404571090000),
    FRACT(-0.49156291610655010000), FRACT(-0.48083933060033390000),
    FRACT(-0.47004333245959560000), FRACT(-0.45917654752194410000),
    FRACT(-0.44824061228522000000), FRACT(-0.43723717366104420000),
    FRACT(-0.42616788872679960000), FRACT(-0.41503442447608160000),
    FRACT(-0.40383845756765410000), FRACT(-0.39258167407295150000),
    FRACT(-0.38126576922216250000), FRACT(-0.36989244714893430000),
    FRACT(-0.35846342063373650000), FRACT(-0.34698041084592370000),
    FRACT(-0.33544514708453170000), FRACT(-0.32385936651785300000),
    FRACT(-0.31222481392182510000), FRACT(-0.30054324141727340000),
    FRACT(-0.28881640820604950000), FRACT(-0.27704608030610000000),
    FRACT(-0.26523403028551190000), FRACT(-0.25338203699557030000),
    FRACT(-0.24149188530286930000), FRACT(-0.22956536582051890000),
    FRACT(-0.21760427463848370000), FRACT(-0.20561041305309930000),
    FRACT(-0.19358558729580370000), FRACT(-0.18153160826112510000),
    FRACT(-0.16945029123396790000), FRACT(-0.15734345561623830000),
    FRACT(-0.14521292465284750000), FRACT(-0.13306052515713920000),
    FRACT(-0.12088808723577720000), FRACT(-0.10869744401313870000),
    FRACT(-0.09649043135525261000), FRACT(-0.08426888759332413000),
    FRACT(-0.07203465324688942000), FRACT(-0.05978957074664001000),
    FRACT(-0.04753548415695926000), FRACT(-0.03527423889821395000),
    FRACT(-0.02300768146883941000), FRACT(-0.01073765916726457000) };

/*! Half-block-size sine array */
DLB_fract32 zsin1[GBL_BLKSIZE/2] =
{   FRACT(-0.00153398018628476500), FRACT(-0.01380538852806039000),
    FRACT(-0.02607471782910390000), FRACT(-0.03834012037355269000),
    FRACT(-0.05059974903689928000), FRACT(-0.06285175756416141000),
    FRACT(-0.07509430084792131000), FRACT(-0.08732553520619206000),
    FRACT(-0.09954361866006932000), FRACT(-0.11174671121112660000),
    FRACT(-0.12393297511851220000), FRACT(-0.13610057517570620000),
    FRACT(-0.14824767898689600000), FRACT(-0.16037245724292830000),
    FRACT(-0.17247308399679600000), FRACT(-0.18454773693861960000),
    FRACT(-0.19659459767008020000), FRACT(-0.20861185197826350000),
    FRACT(-0.22059769010887350000), FRACT(-0.23255030703877520000),
    FRACT(-0.24446790274782420000), FRACT(-0.25634868248994290000),
    FRACT(-0.26819085706340320000), FRACT(-0.27999264308027320000),
    FRACT(-0.29175226323498930000), FRACT(-0.30346794657201130000),
    FRACT(-0.31513792875252240000), FRACT(-0.32676045232013170000),
    FRACT(-0.33833376696554110000), FRACT(-0.34985612979013490000),
    FRACT(-0.36132580556845430000), FRACT(-0.37274106700951580000),
    FRACT(-0.38410019501693500000), FRACT(-0.39540147894781640000),
    FRACT(-0.40664321687036900000), FRACT(-0.41782371582021230000),
    FRACT(-0.42894129205532950000), FRACT(-0.43999427130963330000),
    FRACT(-0.45098098904510390000), FRACT(-0.46189979070246270000),
    FRACT(-0.47274903195034280000), FRACT(-0.48352707893291870000),
    FRACT(-0.49423230851595970000), FRACT(-0.50486310853126760000),
    FRACT(-0.51541787801946290000), FRACT(-0.52589502747108460000),
    FRACT(-0.53629297906596320000), FRACT(-0.54661016691083490000),
    FRACT(-0.55684503727516010000), FRACT(-0.56699604882510870000),
    FRACT(-0.57706167285567940000), FRACT(-0.58704039352091800000),
    FRACT(-0.59693070806219650000), FRACT(-0.60673112703452450000),
    FRACT(-0.61644017453085360000), FRACT(-0.62605638840434350000),
    FRACT(-0.63557832048855610000), FRACT(-0.64500453681554390000),
    FRACT(-0.65433361783180040000), FRACT(-0.66356415861203980000),
    FRACT(-0.67269476907077290000), FRACT(-0.68172407417164970000),
    FRACT(-0.69065071413453460000), FRACT(-0.69947334464028380000),
    FRACT(-0.70819063703319530000), FRACT(-0.71680127852109950000),
    FRACT(-0.72530397237306070000), FRACT(-0.73369743811466030000),
    FRACT(-0.74198041172083100000), FRACT(-0.75015164580621500000),
    FRACT(-0.75820990981301530000), FRACT(-0.76615399019631280000),
    FRACT(-0.77398269060682280000), FRACT(-0.78169483207105940000),
    FRACT(-0.78928925316888570000), FRACT(-0.79676481020841870000),
    FRACT(-0.80412037739826570000), FRACT(-0.81135484701706370000),
    FRACT(-0.81846712958029870000), FRACT(-0.82545615400437740000),
    FRACT(-0.83232086776792970000), FRACT(-0.83906023707031260000),
    FRACT(-0.84567324698729910000), FRACT(-0.85215890162391980000),
    FRACT(-0.85851622426444270000), FRACT(-0.86474425751946240000),
    FRACT(-0.87084206347007890000), FRACT(-0.87680872380914580000),
    FRACT(-0.88264333997956280000), FRACT(-0.88834503330959620000),
    FRACT(-0.89391294514520330000), FRACT(-0.89934623697934150000),
    FRACT(-0.90464409057824620000), FRACT(-0.90980570810465220000),
    FRACT(-0.91483031223794610000), FRACT(-0.91971714629122740000),
    FRACT(-0.92446547432526260000), FRACT(-0.92907458125931570000),
    FRACT(-0.93354377297883620000), FRACT(-0.93787237643998990000),
    FRACT(-0.94205973977101730000), FRACT(-0.94610523237040330000),
    FRACT(-0.95000824500184300000), FRACT(-0.95376818988599030000),
    FRACT(-0.95738450078897590000), FRACT(-0.96085663310767970000),
    FRACT(-0.96418406395174570000), FRACT(-0.96736629222232850000),
    FRACT(-0.97040283868755550000), FRACT(-0.97329324605469820000),
    FRACT(-0.97603707903903900000), FRACT(-0.97863392442942310000),
    FRACT(-0.98108339115048660000), FRACT(-0.98338511032155120000),
    FRACT(-0.98553873531217610000), FRACT(-0.98754394179435920000),
    FRACT(-0.98940042779138040000), FRACT(-0.99110791372327680000),
    FRACT(-0.99266614244894800000), FRACT(-0.99407487930487940000),
    FRACT(-0.99533391214048230000), FRACT(-0.99644305135004260000),
    FRACT(-0.99740212990127530000), FRACT(-0.99821100336047820000),
    FRACT(-0.99886954991428360000), FRACT(-0.99937767038800280000),
    FRACT(-0.99973528826056170000), FRACT(-0.99994234967602390000) };


/*! Quarter-block-size cosine array */
DLB_fract32 zcos2[GBL_BLKSIZE/4] =
{   FRACT(-0.99999529380957620000), FRACT(-0.99961882249517860000),
    FRACT(-0.99864021818026530000), FRACT(-0.99706007033948300000),
    FRACT(-0.99487933079480560000), FRACT(-0.99209931314219180000),
    FRACT(-0.98872169196032380000), FRACT(-0.98474850180190420000),
    FRACT(-0.98018213596811740000), FRACT(-0.97502534506699410000),
    FRACT(-0.96928123535654850000), FRACT(-0.96295326687368390000),
    FRACT(-0.95604525134999640000), FRACT(-0.94856134991573030000),
    FRACT(-0.94050607059326830000), FRACT(-0.93188426558166810000),
    FRACT(-0.92270112833387860000), FRACT(-0.91296219042839820000),
    FRACT(-0.90267331823725880000), FRACT(-0.89184070939234270000),
    FRACT(-0.88047088905216080000), FRACT(-0.86857070597134090000),
    FRACT(-0.85614732837519450000), FRACT(-0.84320823964184540000),
    FRACT(-0.82976123379452300000), FRACT(-0.81581441080673380000),
    FRACT(-0.80137617172314020000), FRACT(-0.78645521359908580000),
    FRACT(-0.77106052426181380000), FRACT(-0.75520137689653650000),
    FRACT(-0.73888732446061510000), FRACT(-0.72212819392921530000),
    FRACT(-0.70493408037590500000), FRACT(-0.68731534089175920000),
    FRACT(-0.66928258834663600000), FRACT(-0.65084668499638100000),
    FRACT(-0.63201873593980910000), FRACT(-0.61281008242940970000),
    FRACT(-0.59323229503979980000), FRACT(-0.57329716669804230000),
    FRACT(-0.55301670558002760000), FRACT(-0.53240312787719800000),
    FRACT(-0.51146885043797050000), FRACT(-0.49022648328829110000),
    FRACT(-0.46868882203582800000), FRACT(-0.44686884016237430000),
    FRACT(-0.42477968120910880000), FRACT(-0.40243465085941850000),
    FRACT(-0.37984720892405110000), FRACT(-0.35703096123343000000),
    FRACT(-0.33399965144200950000), FRACT(-0.31076715274961150000),
    FRACT(-0.28734745954472960000), FRACT(-0.26375467897483150000),
    FRACT(-0.24000302244874150000), FRACT(-0.21610679707621960000),
    FRACT(-0.19208039704989240000), FRACT(-0.16793829497473120000),
    FRACT(-0.14369503315029460000), FRACT(-0.11936521481099140000),
    FRACT(-0.09496349532963906000), FRACT(-0.07050457338961401000),
    FRACT(-0.04600318213091464000), FRACT(-0.02147408027546961000) };

/*! Quarter-block-size sine array */
DLB_fract32 zsin2[GBL_BLKSIZE/4] =
{   FRACT(-0.00306795676296597600), FRACT(-0.02760814577896574000),
    FRACT(-0.05213170468028332000), FRACT(-0.07662386139203149000),
    FRACT(-0.10106986275482780000), FRACT(-0.12545498341154620000),
    FRACT(-0.14976453467732150000), FRACT(-0.17398387338746380000),
    FRACT(-0.19809841071795360000), FRACT(-0.22209362097320350000),
    FRACT(-0.24595505033579460000), FRACT(-0.26966832557291510000),
    FRACT(-0.29321916269425860000), FRACT(-0.31659337555616580000),
    FRACT(-0.33977688440682690000), FRACT(-0.36275572436739720000),
    FRACT(-0.38551605384391880000), FRACT(-0.40804416286497870000),
    FRACT(-0.43032648134008260000), FRACT(-0.45234958723377090000),
    FRACT(-0.47410021465055000000), FRACT(-0.49556526182577250000),
    FRACT(-0.51673179901764990000), FRACT(-0.53758707629564540000),
    FRACT(-0.55811853122055610000), FRACT(-0.57831379641165560000),
    FRACT(-0.59816070699634230000), FRACT(-0.61764730793780390000),
    FRACT(-0.63676186123628420000), FRACT(-0.65549285299961530000),
    FRACT(-0.67382900037875600000), FRACT(-0.69175925836415770000),
    FRACT(-0.70927282643886560000), FRACT(-0.72635915508434600000),
    FRACT(-0.74300795213512170000), FRACT(-0.75920918897838800000),
    FRACT(-0.77495310659487380000), FRACT(-0.79023022143731000000),
    FRACT(-0.80503133114296370000), FRACT(-0.81934752007679690000),
    FRACT(-0.83317016470191320000), FRACT(-0.84649093877405200000),
    FRACT(-0.85930181835700840000), FRACT(-0.87159508665595110000),
    FRACT(-0.88336333866573160000), FRACT(-0.89459948563138260000),
    FRACT(-0.90529675931811880000), FRACT(-0.91544871608826780000),
    FRACT(-0.92504924078267760000), FRACT(-0.93409255040425890000),
    FRACT(-0.94257319760144690000), FRACT(-0.95048607394948170000),
    FRACT(-0.95782641302753290000), FRACT(-0.96458979328981260000),
    FRACT(-0.97077214072895040000), FRACT(-0.97636973133002110000),
    FRACT(-0.98137919331375460000), FRACT(-0.98579750916756740000),
    FRACT(-0.98962201746320080000), FRACT(-0.99285041445986510000),
    FRACT(-0.99548075549192690000), FRACT(-0.99751145614030350000),
    FRACT(-0.99894129318685690000), FRACT(-0.99976940535121530000) };

/*! Bit-reversed, negated cosine array */
DLB_fract32 brxcos[GBL_BLKSIZE/4] =         /* Stored in bit reversed, negated order */
{   FRACT(-1.0000000000000000000), FRACT(0.00000000000000000000),
    FRACT(-0.7071067811865476000), FRACT(0.70710678118654750000),
    FRACT(-0.9238795325112867000), FRACT(0.38268343236508980000),
    FRACT(-0.3826834323650899000), FRACT(0.92387953251128670000),
    FRACT(-0.9807852804032304000), FRACT(0.19509032201612820000),
    FRACT(-0.5555702330196022000), FRACT(0.83146961230254520000),
    FRACT(-0.8314696123025455000), FRACT(0.55557023301960220000),
    FRACT(-0.1950903220161286000), FRACT(0.98078528040323040000),
    FRACT(-0.9951847266721969000), FRACT(0.09801714032956060000),
    FRACT(-0.6343932841636455000), FRACT(0.77301045336273700000),
    FRACT(-0.8819212643483550000), FRACT(0.47139673682599760000),
    FRACT(-0.2902846772544624000), FRACT(0.95694033573220890000),
    FRACT(-0.9569403357322089000), FRACT(0.29028467725446230000),
    FRACT(-0.4713967368259979000), FRACT(0.88192126434835490000),
    FRACT(-0.7730104533627371000), FRACT(0.63439328416364550000),
    FRACT(-0.0980171403295608300), FRACT(0.99518472667219680000),
    FRACT(-0.9987954562051724000), FRACT(0.04906767432741801000),
    FRACT(-0.6715589548470186000), FRACT(0.74095112535495910000),
    FRACT(-0.9039892931234434000), FRACT(0.42755509343028210000),
    FRACT(-0.3368898533922203000), FRACT(0.94154406518302080000),
    FRACT(-0.9700312531945440000), FRACT(0.24298017990326390000),
    FRACT(-0.5141027441932218000), FRACT(0.85772861000027210000),
    FRACT(-0.8032075314806449000), FRACT(0.59569930449243340000),
    FRACT(-0.1467304744553618000),  FRACT(0.98917650996478100000),
    FRACT(-0.9891765099647810000), FRACT(0.14673047445536170000),
    FRACT(-0.5956993044924335000), FRACT(0.80320753148064480000),
    FRACT(-0.8577286100002721000), FRACT(0.51410274419322170000),
    FRACT(-0.2429801799032641000), FRACT(0.97003125319454400000),
    FRACT(-0.9415440651830208000), FRACT(0.33688985339222010000),
    FRACT(-0.4275550934302820000), FRACT(0.90398929312344330000),
    FRACT(-0.7409511253549590000), FRACT(0.67155895484701830000),
    FRACT(-0.0490676743274179700), FRACT(0.99879545620517240000)};

/*! Bit-reversed, negated sine array */
DLB_fract32 brxsin[GBL_BLKSIZE/4] =         /* Stored in bit reversed, negated order */
{  FRACT( 0.00000000000000000000), FRACT(-1.0000000000000000000),
   FRACT(-0.70710678118654750000), FRACT(-0.7071067811865476000),
   FRACT(-0.38268343236508980000), FRACT(-0.9238795325112867000),
   FRACT(-0.92387953251128670000), FRACT(-0.3826834323650899000),
   FRACT(-0.19509032201612820000), FRACT(-0.9807852804032304000),
   FRACT(-0.83146961230254520000), FRACT(-0.5555702330196022000),
   FRACT(-0.55557023301960220000), FRACT(-0.8314696123025455000),
   FRACT(-0.98078528040323040000), FRACT(-0.1950903220161286000),
   FRACT(-0.09801714032956060000), FRACT(-0.9951847266721969000),
   FRACT(-0.77301045336273700000), FRACT(-0.6343932841636455000),
   FRACT(-0.47139673682599760000), FRACT(-0.8819212643483550000),
   FRACT(-0.95694033573220890000), FRACT(-0.2902846772544624000),
   FRACT(-0.29028467725446230000), FRACT(-0.9569403357322089000),
   FRACT(-0.88192126434835490000), FRACT(-0.4713967368259979000),
   FRACT(-0.63439328416364550000), FRACT(-0.7730104533627371000),
   FRACT(-0.99518472667219680000), FRACT(-0.0980171403295608300),
   FRACT(-0.04906767432741801000), FRACT(-0.9987954562051724000),
   FRACT(-0.74095112535495910000), FRACT(-0.6715589548470186000),
   FRACT(-0.42755509343028210000), FRACT(-0.9039892931234434000),
   FRACT(-0.94154406518302080000), FRACT(-0.3368898533922203000),
   FRACT(-0.24298017990326390000), FRACT(-0.9700312531945440000),
   FRACT(-0.85772861000027210000), FRACT(-0.5141027441932218000),
   FRACT(-0.59569930449243340000), FRACT(-0.8032075314806449000),
   FRACT(-0.98917650996478100000), FRACT(-0.1467304744553618000),
   FRACT(-0.14673047445536170000), FRACT(-0.9891765099647810000),
   FRACT(-0.80320753148064480000), FRACT(-0.5956993044924335000),
   FRACT(-0.51410274419322170000), FRACT(-0.8577286100002721000),
   FRACT(-0.97003125319454400000), FRACT(-0.2429801799032641000),
   FRACT(-0.33688985339222010000), FRACT(-0.9415440651830208000),
   FRACT(-0.90398929312344330000), FRACT(-0.4275550934302820000),
   FRACT(-0.67155895484701830000), FRACT(-0.7409511253549590000),
   FRACT(-0.99879545620517240000), FRACT(-0.0490676743274179700)};

/*! Bit-reversed indexing array */
DSPshort bitrevary[GBL_BLKSIZE / 2] =
{   0, 64, 32, 96, 16, 80, 48, 112, 8, 72, 40, 104, 24, 88, 56, 120,
    4, 68, 36, 100, 20, 84, 52, 116, 12, 76, 44, 108, 28, 92, 60, 124,
    2, 66, 34, 98, 18, 82, 50, 114, 10, 74, 42, 106, 26, 90, 58, 122,
    6, 70, 38, 102, 22, 86, 54, 118, 14, 78, 46, 110, 30, 94, 62, 126,
    1, 65, 33, 97, 17, 81, 49, 113, 9, 73, 41, 105, 25, 89, 57, 121,
    5, 69, 37, 101, 21, 85, 53, 117, 13, 77, 45, 109, 29, 93, 61, 125,
    3, 67, 35, 99, 19, 83, 51, 115, 11, 75, 43, 107, 27, 91, 59, 123,
    7, 71, 39, 103, 23, 87, 55, 119, 15, 79, 47, 111, 31, 95, 63, 127};

/*! Table of window values */
DLB_fract32 window[GBL_BLKSIZE] =
{
    FRACT(0.00013599222102497970), FRACT(0.00024390075569190740),
    FRACT(0.00036650249012168420), FRACT(0.00050775455634249020),
    FRACT(0.00067003741545111320), FRACT(0.00085540018968976050),
    FRACT(0.00106582120878971700), FRACT(0.00130328810777037200),
    FRACT(0.00156982798766209500), FRACT(0.00186752016070029800),
    FRACT(0.00219850172477049000), FRACT(0.00256496979050667600),
    FRACT(0.00296918196552255300), FRACT(0.00341345583164787600),
    FRACT(0.00390016777773989800), FRACT(0.00443175137772520200),
    FRACT(0.00501069541836261300), FRACT(0.00563954163710084100),
    FRACT(0.00632088220659456300), FRACT(0.00705735698917348000),
    FRACT(0.00785165057699395300), FRACT(0.00870648912923880700),
    FRACT(0.00962463701522140900), FRACT(0.01060889327084518000),
    FRACT(0.01166208787513903000), FRACT(0.01278707785327832000),
    FRACT(0.01398674321245617000), FRACT(0.01526398271709502000),
    FRACT(0.01662170951012335000), FRACT(0.01806284658734745000),
    FRACT(0.01959032213229660000), FRACT(0.02120706471929521000),
    FRACT(0.02291599839290348000), FRACT(0.02472003763226172000),
    FRACT(0.02662208220926438000), FRACT(0.02862501194987473000),
    FRACT(0.03073168140826510000), FRACT(0.03294491446382805000),
    FRACT(0.03526749885144791000), FRACT(0.03770218063574844000),
    FRACT(0.04025165864033783000), FRACT(0.04291857884335669000),
    FRACT(0.04570552875089542000), FRACT(0.04861503176008421000),
    FRACT(0.05164954152386971000), FRACT(0.05481143632967689000),
    FRACT(0.05810301350431179000), FRACT(0.06152648385758921000),
    FRACT(0.06508396617726904000), FRACT(0.06877748178795473000),
    FRACT(0.07260894918664700000), FRACT(0.07658017876765444000),
    FRACT(0.08069286764954062000), FRACT(0.08494859461673288000),
    FRACT(0.08934881518833321000), FRACT(0.09389485682655344000),
    FRACT(0.09858791429704832000), FRACT(0.10342904519323890000),
    FRACT(0.10841916563650530000), FRACT(0.11355904616388530000),
    FRACT(0.11884930781463720000), FRACT(0.12429041842672210000),
    FRACT(0.12988268915392190000), FRACT(0.13562627121394420000),
    FRACT(0.14152115287747020000), FRACT(0.14756715670767640000),
    FRACT(0.15376393705931050000), FRACT(0.16011097784592470000),
    FRACT(0.16660759058336360000), FRACT(0.17325291271707610000),
    FRACT(0.18004590624027020000), FRACT(0.18698535660935180000),
    FRACT(0.19406987196249550000), FRACT(0.20129788264657720000),
    FRACT(0.20866764105706680000), FRACT(0.21617722179482510000),
    FRACT(0.22382452214308330000), FRACT(0.23160726286720280000),
    FRACT(0.23952298933911760000), FRACT(0.24756907298765980000),
    FRACT(0.25574271307525080000), FRACT(0.26404093880072350000),
    FRACT(0.27246061172731150000), FRACT(0.28099842853410780000),
    FRACT(0.28965092408856810000), FRACT(0.29841447483689030000),
    FRACT(0.30728530250837750000), FRACT(0.31625947812915590000),
    FRACT(0.32533292633989470000), FRACT(0.33450143001145930000),
    FRACT(0.34376063515171320000), FRACT(0.35310605609598990000),
    FRACT(0.36253308097306210000), FRACT(0.37203697743776400000),
    FRACT(0.38161289866076330000), FRACT(0.39125588956533360000),
    FRACT(0.40096089330035910000), FRACT(0.41072275793819400000),
    FRACT(0.42053624338542490000), FRACT(0.43039602849401680000),
    FRACT(0.44029671835979840000), FRACT(0.45023285179472930000),
    FRACT(0.46019890895891440000), FRACT(0.47018931913787830000),
    FRACT(0.48019846865019380000), FRACT(0.49022070887016580000),
    FRACT(0.50025036434991710000), FRACT(0.51028174102489790000),
    FRACT(0.52030913448655070000), FRACT(0.53032683830560710000),
    FRACT(0.54032915238927760000), FRACT(0.55031039135540850000),
    FRACT(0.56026489290654190000), FRACT(0.57018702618670230000),
    FRACT(0.58007120010366910000), FRACT(0.58991187159946430000),
    FRACT(0.59970355385179350000), FRACT(0.60944082438922710000),
    FRACT(0.61911833310300200000), FRACT(0.62873081013844550000),
    FRACT(0.63827307364919760000), FRACT(0.64774003739761270000),
    FRACT(0.65712671818496890000), FRACT(0.66642824309540150000),
    FRACT(0.67563985653780090000), FRACT(0.68475692707028180000),
    FRACT(0.69377495399222980000), FRACT(0.70268957368937430000),
    FRACT(0.71149656571781540000), FRACT(0.72019185861343900000),
    FRACT(0.72877153541371600000), FRACT(0.73723183887945320000),
    FRACT(0.74556917640469600000), FRACT(0.75378012460362260000),
    FRACT(0.76186143356396490000), FRACT(0.76981003075720330000),
    FRACT(0.77762302459652930000), FRACT(0.78529770763434710000),
    FRACT(0.79283155939189220000), FRACT(0.80022224881437120000),
    FRACT(0.80746763634588940000), FRACT(0.81456577561931090000),
    FRACT(0.82151491475710000000), FRACT(0.82831349728011890000),
    FRACT(0.83496016262230000000), FRACT(0.84145374625007490000),
    FRACT(0.84779327938641900000), FRACT(0.85397798834036520000),
    FRACT(0.86000729344384020000), FRACT(0.86588080759869920000),
    FRACT(0.87159833443784910000), FRACT(0.87715986610538050000),
    FRACT(0.88256558066166320000), FRACT(0.88781583912038040000),
    FRACT(0.89291118212551570000), FRACT(0.89785232627731880000),
    FRACT(0.90264016011729620000), FRACT(0.90727573978326750000),
    FRACT(0.91176028434651850000), FRACT(0.91609517084404420000),
    FRACT(0.92028192901981940000), FRACT(0.92432223578994920000),
    FRACT(0.92821790944743860000), FRACT(0.93197090362316550000),
    FRACT(0.93558330102045760000), FRACT(0.93905730694143010000),
    FRACT(0.94239524262396900000), FRACT(0.94559953840889810000),
    FRACT(0.94867272675748120000), FRACT(0.95161743513994920000),
    FRACT(0.95443637881622230000), FRACT(0.95713235353039820000),
    FRACT(0.95970822814090870000), FRACT(0.96216693720849690000),
    FRACT(0.96451147356432880000), FRACT(0.96674488088063350000),
    FRACT(0.96887024626625370000), FRACT(0.97089069290937860000),
    FRACT(0.97280937278953210000), FRACT(0.97462945948058680000),
    FRACT(0.97635414106617660000), FRACT(0.97798661318838080000),
    FRACT(0.97953007224995660000), FRACT(0.98098770878969780000),
    FRACT(0.98236270104970590000), FRACT(0.98365820875247110000),
    FRACT(0.98487736710468150000), FRACT(0.98602328104361040000),
    FRACT(0.98709901974078680000), FRACT(0.98810761137642330000),
    FRACT(0.98905203819678400000), FRACT(0.98993523186531360000),
    FRACT(0.99076006911693930000), FRACT(0.99152936772349120000),
    FRACT(0.99224588277669910000), FRACT(0.99291230329369070000),
    FRACT(0.99353124914838440000), FRACT(0.99410526833061520000),
    FRACT(0.99463683453329610000), FRACT(0.99512834506638300000),
    FRACT(0.99558211909491500000), FRACT(0.99600039619692990000),
    FRACT(0.99638533523564190000), FRACT(0.99673901353889730000),
    FRACT(0.99706342637763750000), FRACT(0.99736048673386460000),
    FRACT(0.99763202534747640000), FRACT(0.99787979103028050000),
    FRACT(0.99810545123454870000), FRACT(0.99831059286262110000),
    FRACT(0.99849672330332570000), FRACT(0.99866527168034350000),
    FRACT(0.99881759029713050000), FRACT(0.99895495626259410000),
    FRACT(0.99907857328143460000), FRACT(0.99918957359287030000),
    FRACT(0.99928902004140410000), FRACT(0.99937790826331730000),
    FRACT(0.99945716897272360000), FRACT(0.99952767033125260000),
    FRACT(0.99959022038576870000), FRACT(0.99964556955895290000),
    FRACT(0.99969441317807690000), FRACT(0.99973739402788000000),
    FRACT(0.99977510491409590000), FRACT(0.99980809122488750000),
    FRACT(0.99983685347818720000), FRACT(0.99986184984374770000),
    FRACT(0.99988349862952150000), FRACT(0.99990218072284900000),
    FRACT(0.99991824197780000000), FRACT(0.99993199554089310000),
    FRACT(0.99994372410829590000), FRACT(0.99995368210848910000),
    FRACT(0.99996209780523300000), FRACT(0.99996917531652780000),
    FRACT(0.99997509654607260000), FRACT(0.99998002302452540000),
    FRACT(0.99998409765861940000), FRACT(0.99998744638691550000),
    FRACT(0.99999017974164430000), FRACT(0.99999239431672950000),
    FRACT(0.99999417414267240000), FRACT(0.99999559196951250000),
    FRACT(0.99999671045957640000), FRACT(0.99999758329216290000),
    FRACT(0.99999825618270430000), FRACT(0.99999876781928550000),
    FRACT(0.99999915071969350000), FRACT(0.99999943201241430000),
    FRACT(0.99999963414519090000), FRACT(0.99999977552490580000),
    FRACT(0.99999987109264700000), FRACT(0.99999993283796020000),
    FRACT(0.99999997025621030000), FRACT(0.99999999075305790000)
};


/*!

\brief  32-bit add with saturation

\return 32-bit result

*/
DLB_fract32 DLB_sadd(DLB_fract32 x, /*!< First  operand */
                   DLB_fract32 y  /*!< Second operand */
                   )
{
  DLB_fract32 result = x + y;

  if( (x < 0) && (y < 0) && (result >= 0) ){
#if defined(DEBUG_TOOLS)
    DLB_dprintf(LSI_INFO, "Saturation in DLB_sadd() or DLB_ssub(): Setting %f to the largest possible negative value.\n", ((float)x+(float)y)/FRACT_FIX_SCALE);
#endif /* defined(DEBUG_TOOLS) */
    result = DLB_INT_MIN;
  }
  else if ( (x >= 0) && (y >= 0) && (result < 0) ) {
#if defined(DEBUG_TOOLS)
    DLB_dprintf(LSI_INFO, "Saturation in DLB_sadd() or DLB_ssub(): Setting %f to the largest possible positive value.\n", ((float)x+(float)y)/FRACT_FIX_SCALE);
#endif /* defined(DEBUG_TOOLS) */
    result = DLB_INT_MAX;
  }
  return result;
}

/*!

\brief  32-bit Negate with saturation

\return 32-bit result

*/
DLB_fract32 DLB_sneg32(DLB_fract32 x)
{

  if (x == DLB_INT_MIN) {
#if defined(DEBUG_TOOLS)
    DLB_dprintf(LSI_INFO, "Saturation in DLB_sneg32: Setting to the largest possible positive value.\n");
#endif /* defined(DEBUG_TOOLS) */
    return DLB_INT_MAX;
  }
  return -x;
}


/*!

\brief  32-bit sub with saturation

\return 32-bit result

*/
DLB_fract32 DLB_ssub(DLB_fract32 x, /*!< First  operand */
                   DLB_fract32 y  /*!< Second operand */
                   )
{
  DLB_fract32 result;

  result = DLB_sadd(x,DLB_sneg32(y));

  return result;
}

/*!
  \brief  Count leading bits equal to sign bit

  The number of leading bits is often called the exponent.

  \return Exponent
*/
DLB_uint16 DLB_norm32(DLB_fract32 op)
{
  int i;
  DLB_fract32 a = ~op>>31;

  for ( i = 0 ; i < 32 ; i++ ) {
    if ( ! (( op>>(31-i) ^ a ) & 1) )
      return (i-1) ;
  }
  return (i-1);
}


/*!
  \brief  Bidirectional shift left with saturation

  Shift paramater might be positive or negative.

  \return 32-bit result

*/
DLB_fract32 DLB_sshl(DLB_fract32 x,   /*!< Value to be shifted */ 
                   DLB_int16 shift  /*!< Shift parameter */
                   )
{
  DLB_int16 exp;

  if(shift <= 0){
    if(shift <= -32) {
      /*
        generic workaround for sign-true arithmetic shifts beyond data width 
      */
      if (x < 0)
        return -1;
      else
        return 0;
    }
    else
      return x >> (-shift);
  }

  exp = DLB_norm32(x);

  if ( (shift <= exp) || (x == 0) ){
    return x << shift;
  }
  
  if (x < 0 ) {
#if defined(DEBUG_TOOLS)
    DLB_dprintf(LSI_INFO, "Saturation in DLB_sshl(): Setting %f to the largest possible negative value.\n", (float)x/FRACT_FIX_SCALE*(1<<shift));
#endif /* defined(DEBUG_TOOLS) */
    return DLB_INT_MIN;
  }
  else {
#if defined(DEBUG_TOOLS)
    DLB_dprintf(LSI_INFO, "Saturation in DLB_sshl(): Setting %f to the largest possible positive value.\n", (float)x/FRACT_FIX_SCALE*(1<<shift));
#endif /* defined(DEBUG_TOOLS) */
    return DLB_INT_MAX;
  }
}

DLB_fract32 DLB_sshr(DLB_fract32 x,   /*!< Value to be shifted */ 
                   DLB_int16 shift  /*!< Shift parameter */
                   )
{
  DLB_fract32 result;

  result = DLB_sshl(x, -shift);

  return result;
}

/****************************************************************************/
DLB_fract32 DLB_mpy32x32(DLB_fract32 x, /*!< 32-bit operand */
                       DLB_fract32 y  /*!< 32-bit operand */
                       )
{
  /* This implementation of the 32x32-bit multiplication makes use
     of three 16-bit multiplications, instead of four 16-bit 
     multiplications. The multiplication of both low 16-bit parts is
     kept out. This kind of simplified multiplication is tipically
     implemented for many DSPs.
     It is important to stress that this method, although it is faster
     than a full multiplication, has the side effect that, in case of
     the multiplication of two small negative values, the calculated
     value can also be negative. For example, given the multiplication
     of x * x:

     if x = -0.0000152583 (ffff8001),

     x * x (full version)   =  0.0000000000 (00000000)
     x * x (simpl. version) = -0.0000000009 (fffffffe)

     if x = -0.0000000009 (fffffffe),

     x * x (full version)   =  0.0000000000 (00000000)
     x * x (simpl. version) = -0.0000000009 (fffffffe)

     This effect shows up, because of the sign extension of the negative
     numbers. The upper parts of the 32-bit operands (see the variables
     "uh" and "vh" in the source-code below) should be zero in this case,
     but they still hold 0xffff. Therefore, when they are used in the
     multiplication, they generate a small negative number.
  */
  DLB_fract32 product;
  DLB_int16  uh = (x>>16) & 0xffff;
  DLB_uint16 ul =  x      & 0xffff;
  DLB_int16  vh = (y>>16) & 0xffff;
  DLB_uint16 vl =  y      & 0xffff;

  if ((DLB_uint32)x == 0x80000000 && (DLB_uint32)y == 0x80000000) {
    /* -1 * -1 must not result in -1 */
#if defined(DEBUG_TOOLS)
    DLB_dprintf(LSI_INFO, "Saturation in DLB_mpy32x32(): Setting to the largest possible positive value.\n");
#endif /* defined(DEBUG_TOOLS) */
    product = DLB_INT_MAX;
  }
  else {
    product = (uh * vh) * 2 + ((uh * vl) >> 15) + ((ul * vh) >> 15);
  }

#if defined(DEBUG_TOOLS)
  {
    DLB_fract32 product_nodrop;

    if ((DLB_uint32)x == 0x80000000 && (DLB_uint32)y == 0x80000000) {
      /* -1 * -1 must not result in -1 */
      product_nodrop = DLB_INT_MAX;
    }
    else {
      product_nodrop = (((int64)x * (int64)y ) >> 31);
    }

    if (product_nodrop >= 0 && product < 0) {
      DLB_dprintf(LSI_INFO, "Change of sign in DLB_mpy32x32(): simplified multiplication doesn't match full multiplication\n");
    }
  }
#endif /* defined(DEBUG_TOOLS) */

  return product;
}

/*****************************************************************
* cifft:
*****************************************************************/
short cifft(
            const DSPshort  bswitch,        /* input    */
            DLB_fract32     *p_fftbuf)      /* modify   */          
{
    /* declare local variables */
    DSPshort    i;
    DSPshort    j;
    DSPshort    k;
    DSPshort    m;
    DSPshort    bg;
    DSPshort    gp;
    DSPshort    fftn;
    DSPshort    fftnlg2m3;
    DSPshort    nstep;
    DLB_fract32 ar;
    DLB_fract32 ai;
    DLB_fract32 br;
    DLB_fract32 bi;
    DLB_fract32 cr;
    DLB_fract32 ci;
    DLB_fract32 dr;
    DLB_fract32 di;
    DLB_fract32 aici;
    DLB_fract32 brdr;
    DLB_fract32 arcr;
    DLB_fract32 bidi;
    DLB_fract32 rtemp;
    DLB_fract32 itemp;
    DLB_fract32 *p_fftr;
    DLB_fract32 *p_ffti;
    DLB_fract32 *brxp_cos;
    DLB_fract32 *brxp_sin;
    DLB_fract32 *bfyrptr1;
    DLB_fract32 *bfyiptr1;
    DLB_fract32 *bfyrptr2;
    DLB_fract32 *bfyiptr2;
    DLB_fract32 *bfyrptr3;
    DLB_fract32 *bfyiptr3;
    DLB_fract32 *bfyrptr4;
    DLB_fract32 *bfyiptr4;
    DLB_fract32 brcr, bici, brci, bicr;

#if defined(DEBUG)
    DBG_PRINTB4BHDR(p_dbg, "FFT real buffer (post idctsc)", &p_dbg->dbgfile_imdct);
    for (i = 0; i < GBL_BLKSIZE/2; i++)
    {
        DBG_PRINTB4B(p_dbg, "\t\tfftbuf[bin%03d] = ", &i, T_DSPSHORT, &p_dbg->dbgfile_imdct);
        DBG_PRINTB4B(p_dbg, "% 16.24lf\n", &p_fftbuf[i], T_DSPFRACTSCALED, &p_dbg->dbgfile_imdct);
    }
    DBG_PRINTB4BHDR(p_dbg, "FFT imag buffer (post idctsc)", &p_dbg->dbgfile_imdct);
    for (i = GBL_BLKSIZE/2; i < GBL_BLKSIZE; i++)
    {
        p_dbg->i = i - GBL_BLKSIZE/2;
        DBG_PRINTB4B(p_dbg, "\t\tfftbuf[bin%03d] = ", &p_dbg->i, T_DSPSHORT, &p_dbg->dbgfile_imdct);
        DBG_PRINTB4B(p_dbg, "% 16.24lf\n", &p_fftbuf[i], T_DSPFRACTSCALED, &p_dbg->dbgfile_imdct);
    }
#endif /* defined(DEBUG) */

    /* check input arguments */
    ERR_CHKARG(bswitch == 0 || bswitch == 1);
    ERR_CHKARG(p_fftbuf);

    if (bswitch)
    {
        fftn = GBL_BLKSIZE / 4;
        fftnlg2m3 = GBL_FFTSIZELG2M3 - 1;
        nstep = 2;
        p_fftr = p_fftbuf;
        p_ffti = p_fftbuf + 3*GBL_BLKSIZE/4;
    }
    else
    {
        fftn = GBL_BLKSIZE / 2;
        fftnlg2m3 = GBL_FFTSIZELG2M3;
        nstep = 1;
        p_fftr = p_fftbuf;
        p_ffti = p_fftbuf + GBL_BLKSIZE/2;
    }

    for (m = 0; m < nstep; m++)
    {

        /* do first radix-4 pass */
        bfyrptr1 = p_fftr;
        bfyiptr1 = p_ffti;
        bfyrptr2 = p_fftr + (fftn / 4);
        bfyiptr2 = p_ffti + (fftn / 4);
        bfyrptr3 = p_fftr + (fftn / 2);
        bfyiptr3 = p_ffti + (fftn / 2);
        bfyrptr4 = p_fftr + (3 * fftn / 4);
        bfyiptr4 = p_ffti + (3 * fftn / 4);

        for (i = 0; i < fftn / 4; i++)
        {
            ar = *bfyrptr1;
            ai = *bfyiptr1;
            br = *bfyrptr2;
            bi = *bfyiptr2;
            cr = *bfyrptr3;
            ci = *bfyiptr3;
            dr = *bfyrptr4;
            di = *bfyiptr4;

            aici = DLB_sadd(ai, ci);
            brdr = DLB_sadd(br, dr);
            arcr = DLB_sadd(ar, cr);
            bidi = DLB_sadd(bi, di);

            *bfyrptr1++ = DSPrnd(XFMD_DSPPROCRND, XFMD_DSPPROCBITS, DLB_sadd(arcr, brdr));
            *bfyiptr1++ = DSPrnd(XFMD_DSPPROCRND, XFMD_DSPPROCBITS, DLB_sadd(aici, bidi));
            *bfyrptr2++ = DSPrnd(XFMD_DSPPROCRND, XFMD_DSPPROCBITS, DLB_ssub(arcr, brdr));
            *bfyiptr2++ = DSPrnd(XFMD_DSPPROCRND, XFMD_DSPPROCBITS, DLB_ssub(aici, bidi));

            aici = DLB_ssub(ai, ci);
            brdr = DLB_ssub(br, dr);
            arcr = DLB_ssub(ar, cr);
            bidi = DLB_ssub(bi, di);

            *bfyrptr3++ = DSPrnd(XFMD_DSPPROCRND, XFMD_DSPPROCBITS, DLB_ssub(arcr, bidi));
            *bfyiptr3++ = DSPrnd(XFMD_DSPPROCRND, XFMD_DSPPROCBITS, DLB_sadd(aici, brdr));
            *bfyrptr4++ = DSPrnd(XFMD_DSPPROCRND, XFMD_DSPPROCBITS, DLB_sadd(arcr, bidi));
            *bfyiptr4++ = DSPrnd(XFMD_DSPPROCRND, XFMD_DSPPROCBITS, DLB_ssub(aici, brdr));
        }

        /* do all radix-2 passes except first two and last */
        bg = fftn / 8;      /* butterflies per group */
        gp = 4;             /* groups per pass */

        for (k = 0; k < fftnlg2m3; k++)
        {
            bfyrptr1 = p_fftr;
            bfyiptr1 = p_ffti;
            bfyrptr2 = p_fftr + bg;
            bfyiptr2 = p_ffti + bg;
            brxp_cos = brxcos;
            brxp_sin = brxsin;

            for (j = 0; j < gp; j++)
            {
                cr = *brxp_cos++;
                cr = DLB_sshr(cr, XFMD_BIT_SHIFT);
                ci = *brxp_sin++;
                ci = DLB_sshr(ci, XFMD_BIT_SHIFT);

                for (i = 0; i < bg; i++)
                {
                    ar = *bfyrptr1;
                    ai = *bfyiptr1;
                    br = *bfyrptr2;
                    bi = *bfyiptr2;

                    brcr = DLB_mpy32x32(br, cr);
                    brcr = DLB_sshl(brcr, XFMD_BIT_SHIFT);
                    bici = DLB_mpy32x32(bi, ci);
                    bici = DLB_sshl(bici, XFMD_BIT_SHIFT);
                    brci = DLB_mpy32x32(br, ci);
                    brci = DLB_sshl(brci, XFMD_BIT_SHIFT);
                    bicr = DLB_mpy32x32(bi, cr);
                    bicr = DLB_sshl(bicr, XFMD_BIT_SHIFT);

                    rtemp = DLB_ssub(brcr, bici);
                    itemp = DLB_sadd(brci, bicr);

                    *bfyrptr1++ = DSPrnd(XFMD_DSPPROCRND, XFMD_DSPPROCBITS, DLB_ssub(ar, rtemp));
                    *bfyiptr1++ = DSPrnd(XFMD_DSPPROCRND, XFMD_DSPPROCBITS, DLB_ssub(ai, itemp));
                    *bfyrptr2++ = DSPrnd(XFMD_DSPPROCRND, XFMD_DSPPROCBITS, DLB_sadd(ar, rtemp));
                    *bfyiptr2++ = DSPrnd(XFMD_DSPPROCRND, XFMD_DSPPROCBITS, DLB_sadd(ai, itemp));
                }
                bfyrptr1 += bg;
                bfyiptr1 += bg;
                bfyrptr2 += bg;
                bfyiptr2 += bg;
            }
            bg >>= 1;
            gp <<= 1;
        }

        /* do last radix-2 pass */
        brxp_cos = brxcos;
        brxp_sin = brxsin;
        bfyrptr1 = p_fftr;
        bfyiptr1 = p_ffti;

        for (i = 0; i < fftn / 2; i++)
        {
            ar = *bfyrptr1++;
            ai = *bfyiptr1++;
            br = *bfyrptr1--;
            bi = *bfyiptr1--;
            cr = *brxp_cos++;
            cr = DLB_sshr(cr, XFMD_BIT_SHIFT);
            ci = *brxp_sin++;
            ci = DLB_sshr(ci, XFMD_BIT_SHIFT);

            brcr = DLB_mpy32x32(br, cr);
            brcr = DLB_sshl(brcr, XFMD_BIT_SHIFT);
            bici = DLB_mpy32x32(bi, ci);
            bici = DLB_sshl(bici, XFMD_BIT_SHIFT);
            brci = DLB_mpy32x32(br, ci);
            brci = DLB_sshl(brci, XFMD_BIT_SHIFT);
            bicr = DLB_mpy32x32(bi, cr);
            bicr = DLB_sshl(bicr, XFMD_BIT_SHIFT);

            rtemp = DLB_ssub(brcr, bici);
            itemp = DLB_sadd(brci, bicr);

            *bfyrptr1++ = DSPrnd(XFMD_DSPPROCRND, XFMD_DSPPROCBITS, DLB_ssub(ar, rtemp));
            *bfyiptr1++ = DSPrnd(XFMD_DSPPROCRND, XFMD_DSPPROCBITS, DLB_ssub(ai, itemp));
            *bfyrptr1++ = DSPrnd(XFMD_DSPPROCRND, XFMD_DSPPROCBITS, DLB_sadd(ar, rtemp));
            *bfyiptr1++ = DSPrnd(XFMD_DSPPROCRND, XFMD_DSPPROCBITS, DLB_sadd(ai, itemp));
        }

        p_fftr = p_fftbuf + GBL_BLKSIZE/4;
        p_ffti = p_fftbuf + GBL_BLKSIZE/2;
    }

    return (0);
}

/*****************************************************************
* idctsc2:
*****************************************************************/
short idctsc2(
            const DSPshort  bswitch,        /* input    */
            const DLB_fract32   *p_fftbuf,      /* input    */
            DLB_fract32     *p_tcbuf)       /* output   */
{
    /* declare local variables */
    const DLB_fract32 *p_fftr;
    const DLB_fract32 *p_ffti;
    const DLB_fract32 *p_fftr2;
    const DLB_fract32 *p_ffti2;
    DLB_fract32 *p_tcr;
    DLB_fract32 *p_tci;
    DLB_fract32 *p_tcr2;
    DLB_fract32 *p_tci2;
    DLB_fract32 *p_cos;
    DLB_fract32 *p_sin;
    DLB_fract32 ar;
    DLB_fract32 ai;
    DLB_fract32 cr;
    DLB_fract32 ci;
    DSPshort i;
    DSPshort index;
    DLB_fract32 arcr, aici, arci, aicr;

#if defined(DEBUG)
    DBG_PRINTB4BHDR(p_dbg, "FFT real buffer (post ifft)", &p_dbg->dbgfile_imdct);
    for (i = 0; i < GBL_BLKSIZE/2; i++)
    {
        DBG_PRINTB4B(p_dbg, "\t\tfftbuf[bin%03d] = ", &i, T_DSPSHORT, &p_dbg->dbgfile_imdct);
        DBG_PRINTB4B(p_dbg, "% 16.24lf\n", &p_fftbuf[i], T_DSPFRACTSCALED, &p_dbg->dbgfile_imdct);
    }
    DBG_PRINTB4BHDR(p_dbg, "FFT imag buffer (post ifft)", &p_dbg->dbgfile_imdct);
    for (i = GBL_BLKSIZE/2; i < GBL_BLKSIZE; i++)
    {
        p_dbg->i = i - GBL_BLKSIZE/2;
        DBG_PRINTB4B(p_dbg, "\t\tfftbuf[bin%03d] = ", &p_dbg->i, T_DSPSHORT, &p_dbg->dbgfile_imdct);
        DBG_PRINTB4B(p_dbg, "% 16.24lf\n", &p_fftbuf[i], T_DSPFRACTSCALED, &p_dbg->dbgfile_imdct);
    }
#endif /* defined(DEBUG) */

    /* check input arguments */
    ERR_CHKARG(bswitch == 0 || bswitch == 1);
    ERR_CHKARG(p_fftbuf);

/*  Do complex multiply */

    if (bswitch)
    {
        p_fftr = p_fftbuf;
        p_ffti = p_fftbuf + 3*GBL_BLKSIZE/4;
        p_fftr2 = p_fftbuf + GBL_BLKSIZE/4;
        p_ffti2 = p_fftbuf + GBL_BLKSIZE/2;
        p_tcr = p_tcbuf;
        p_tci = p_tcbuf + 3*GBL_BLKSIZE/4;
        p_tcr2 = p_tcbuf + GBL_BLKSIZE/4;
        p_tci2 = p_tcbuf + GBL_BLKSIZE/2;
        p_cos = zcos2;
        p_sin = zsin2;

        for (i = 0; i < GBL_BLKSIZE/4; i++)
        {
            index = bitrevary[2 * i];
            cr = *p_cos++;
            cr = DLB_sshr(cr, XFMD_BIT_SHIFT);
            ci = *p_sin++;
            ci = DLB_sshr(ci, XFMD_BIT_SHIFT);
            ar = p_fftr[index];
            ai = p_ffti[index];

            arcr = DLB_mpy32x32(ar, cr);
            arcr = DLB_sshl(arcr, XFMD_BIT_SHIFT);
            aici = DLB_mpy32x32(ai, ci);
            aici = DLB_sshl(aici, XFMD_BIT_SHIFT);
            aicr = DLB_mpy32x32(ai, cr);
            aicr = DLB_sshl(aicr, XFMD_BIT_SHIFT);
            arci = DLB_mpy32x32(ar, ci);
            arci = DLB_sshl(arci, XFMD_BIT_SHIFT);

            *p_tcr++ = DLB_sshl(DLB_ssub(arcr, aici), XFMD_BIT_SHIFT);
            *p_tci++ = DLB_sshl(DLB_sadd(aicr, arci), XFMD_BIT_SHIFT);

            ar = p_fftr2[index];
            ai = p_ffti2[index];

            arcr = DLB_mpy32x32(ar, cr);
            arcr = DLB_sshl(arcr, XFMD_BIT_SHIFT);
            aici = DLB_mpy32x32(ai, ci);
            aici = DLB_sshl(aici, XFMD_BIT_SHIFT);
            aicr = DLB_mpy32x32(ai, cr);
            aicr = DLB_sshl(aicr, XFMD_BIT_SHIFT);
            arci = DLB_mpy32x32(ar, ci);
            arci = DLB_sshl(arci, XFMD_BIT_SHIFT);

            *p_tcr2++ = DLB_sshl(DLB_ssub(arcr, aici), XFMD_BIT_SHIFT);
            *p_tci2++ = DLB_sshl(DLB_sadd(aicr, arci), XFMD_BIT_SHIFT);
        }
    }
    else
    {
        p_fftr = p_fftbuf;
        p_ffti = p_fftbuf + GBL_BLKSIZE/2;
        p_tcr = p_tcbuf;
        p_tci = p_tcbuf + GBL_BLKSIZE/2;
        p_cos = zcos1;
        p_sin = zsin1;

        for (i = 0; i < GBL_BLKSIZE/2; i++)
        {
            index = bitrevary[i];
            cr = *p_cos++;
            cr = DLB_sshr(cr, XFMD_BIT_SHIFT);
            ci = *p_sin++;
            ci = DLB_sshr(ci, XFMD_BIT_SHIFT);
            ar = p_fftr[index];
            ai = p_ffti[index];

            arcr = DLB_mpy32x32(ar, cr);
            arcr = DLB_sshl(arcr, XFMD_BIT_SHIFT);
            aici = DLB_mpy32x32(ai, ci);
            aici = DLB_sshl(aici, XFMD_BIT_SHIFT);
            aicr = DLB_mpy32x32(ai, cr);
            aicr = DLB_sshl(aicr, XFMD_BIT_SHIFT);
            arci = DLB_mpy32x32(ar, ci);
            arci = DLB_sshl(arci, XFMD_BIT_SHIFT);

            *p_tcr++ = DLB_sshl(DLB_ssub(arcr, aici), XFMD_BIT_SHIFT);
            *p_tci++ = DLB_sshl(DLB_sadd(aicr, arci), XFMD_BIT_SHIFT);
        }
    }

    return (0);
}


/*****************************************************************
* idctsc:
*****************************************************************/
short idctsc(
            const DSPshort      bswitch,    /* input    */
            const DLB_fract32   *p_tcbuf,   /* input    */
            DLB_fract32         *p_fftbuf)  /* output   */
{
    /* declare local variables */
    DLB_fract32 *p_fftr;
    DLB_fract32 *p_ffti;
    DLB_fract32 *p_fftr2;
    DLB_fract32 *p_ffti2;
    const DLB_fract32 *p_tcr;
    const DLB_fract32 *p_tci;
    DLB_fract32 *p_cos;
    DLB_fract32 *p_sin;
    DLB_fract32 ar;
    DLB_fract32 ai;
    DLB_fract32 cr;
    DLB_fract32 ci;
    DLB_fract32 arcr, aici, aicr, arci;
    DSPshort i;

    /* check input arguments */
    ERR_CHKARG(bswitch == 0 || bswitch == 1);
    ERR_CHKARG(p_tcbuf);
    ERR_CHKARG(p_fftbuf);

    /* do complex multiply */
    if (bswitch)
    {
        /* initialize pointers */
        p_fftr = p_fftbuf;
        p_ffti = p_fftbuf + 3*GBL_BLKSIZE/4;
        p_fftr2 = p_fftbuf + GBL_BLKSIZE/4;
        p_ffti2 = p_fftbuf + GBL_BLKSIZE/2;
        p_tcr = p_tcbuf + GBL_BLKSIZE - 2;
        p_tci = p_tcbuf;
        p_cos = zcos2;
        p_sin = zsin2;

        for (i = 0; i < GBL_BLKSIZE/4; i++)
        {
            cr = *p_cos++;
            cr = DLB_sshr(cr, XFMD_BIT_SHIFT);
            ci = *p_sin++;
            ci = DLB_sshr(ci, XFMD_BIT_SHIFT);
            ar = *p_tcr++;
            ar = DLB_sshr(ar, XFMD_BIT_SHIFT);
            ai = *p_tci++;
            ai = DLB_sshr(ai, XFMD_BIT_SHIFT);

            arcr = DLB_mpy32x32(ar, cr);
            arcr = DLB_sshl(arcr, XFMD_BIT_SHIFT);
            aici = DLB_mpy32x32(ai, ci);
            aici = DLB_sshl(aici, XFMD_BIT_SHIFT);
            aicr = DLB_mpy32x32(ai, cr);
            aicr = DLB_sshl(aicr, XFMD_BIT_SHIFT);
            arci = DLB_mpy32x32(ar, ci);
            arci = DLB_sshl(arci, XFMD_BIT_SHIFT);

            *p_fftr++ = DLB_ssub(arcr, aici);
            *p_ffti++ = DLB_sadd(aicr, arci);

            ar = *p_tcr--;
            ar = DLB_sshr(ar, XFMD_BIT_SHIFT);
            ai = *p_tci--;
            ai = DLB_sshr(ai, XFMD_BIT_SHIFT);

            arcr = DLB_mpy32x32(ar, cr);
            arcr = DLB_sshl(arcr, XFMD_BIT_SHIFT);
            aici = DLB_mpy32x32(ai, ci);
            aici = DLB_sshl(aici, XFMD_BIT_SHIFT);
            aicr = DLB_mpy32x32(ai, cr);
            aicr = DLB_sshl(aicr, XFMD_BIT_SHIFT);
            arci = DLB_mpy32x32(ar, ci);
            arci = DLB_sshl(arci, XFMD_BIT_SHIFT);

            *p_fftr2++ = DSPrnd(XFMD_DSPPROCRND, XFMD_DSPPROCBITS, DLB_ssub(arcr, aici));
            *p_ffti2++ = DSPrnd(XFMD_DSPPROCRND, XFMD_DSPPROCBITS, DLB_sadd(aicr, arci));

            p_tcr -= 4;
            p_tci += 4;
        }
    }
    else
    {
        p_fftr = p_fftbuf;
        p_ffti = p_fftbuf + GBL_BLKSIZE/2;
        p_tcr = p_tcbuf + GBL_BLKSIZE - 1;
        p_tci = p_tcbuf;
        p_cos = zcos1;
        p_sin = zsin1;

        for (i = 0; i < GBL_BLKSIZE/2; i++)
        {
            cr = *p_cos++;
            cr = DLB_sshr(cr, XFMD_BIT_SHIFT);
            ci = *p_sin++;
            ci = DLB_sshr(ci, XFMD_BIT_SHIFT);
            ar = *p_tcr;
            ar = DLB_sshr(ar, XFMD_BIT_SHIFT);
            ai = *p_tci;
            ai = DLB_sshr(ai, XFMD_BIT_SHIFT);

            arcr = DLB_mpy32x32(ar, cr);
            arcr = DLB_sshl(arcr, XFMD_BIT_SHIFT);
            aici = DLB_mpy32x32(ai, ci);
            aici = DLB_sshl(aici, XFMD_BIT_SHIFT);
            aicr = DLB_mpy32x32(ai, cr);
            aicr = DLB_sshl(aicr, XFMD_BIT_SHIFT);
            arci = DLB_mpy32x32(ar, ci);
            arci = DLB_sshl(arci, XFMD_BIT_SHIFT);

            *p_fftr++ = DSPrnd(XFMD_DSPPROCRND, XFMD_DSPPROCBITS, DLB_ssub(arcr, aici));
            *p_ffti++ = DSPrnd(XFMD_DSPPROCRND, XFMD_DSPPROCBITS, DLB_sadd(aicr, arci));

            p_tcr -= 2;
            p_tci += 2;
        }
    }

    return (0);
}

/*****************************************************************
* inverse_transform:
*****************************************************************/
short xfmd_imdct(
            const DSPshort  bswitch,        /* input    */
            DLB_fract32     *p_fftbuf,      /* modify   */
            DLB_fract32     *p_tcbuf)       /* modify   */                      
{
    /* declare local variables */
    short       err;

    /* check input arguments */
    ERR_CHKARG(bswitch == 0 || bswitch == 1);
    ERR_CHKARG(p_fftbuf);
    ERR_CHKARG(p_tcbuf);

    /* perform pre-twiddle */
    err = idctsc(bswitch, p_tcbuf, p_fftbuf);
    ERR_CHKRTN(err);

    /* perform inverse fft */
    err = cifft(bswitch, p_fftbuf);
    ERR_CHKRTN(err);

    /* perform post-twiddle */
    err = idctsc2(bswitch, p_fftbuf, p_tcbuf);
    ERR_CHKRTN(err);

#if defined(DEBUG)
    DBG_PRINTB4BHDR(p_dbg, "IMDCT output (post idctsc2)", &p_dbg->dbgfile_imdct);
    for (p_dbg->i = 0; p_dbg->i < GBL_BLKSIZE; p_dbg->i++)
    {
        DBG_PRINTB4B(p_dbg, "\t\timdct_out[bin%03d] = ", &p_dbg->i, T_DSPSHORT, &p_dbg->dbgfile_imdct);
        DBG_PRINTB4B(p_dbg, "% 16.24lf\n", &p_tcbuf[p_dbg->i], T_DSPFRACT, &p_dbg->dbgfile_imdct);
    }
#endif /* defined(DEBUG) */

    return (err);
}

/*****************************************************************
* woad_decode: Performs window/overlap/add decode
*****************************************************************/
short woad_decode_dol(
    const DSPshort scalefactor,     /* input  */
    const DLB_fract32 *p_dnmix_buf, /* input  */
    DLB_fract32       *p_delaybuf,      /* modify */
    DLB_fract32       *p_working_buf,   /* modify */
    WOAD_PCMPTRS    *p_pcmptrs)     /* output */
{
    /* declare local variables */
    DSPshort i;
    DSPshort offset;
    const DLB_fract32 *p_dnmix1;
    const DLB_fract32 *p_dnmix2;
    DLB_fract32 *p_delay1;
    DLB_fract32 *p_delay2;
    DLB_fract32 *p_wind1;
    DLB_fract32 *p_wind2;
    DLB_fract32 *p_pcm1;
    DLB_fract32 *p_pcm2;
    DLB_fract32 samp;
    DLB_fract32 delayXwin, dnmixXwin;

    /* check input arguments */
    ERR_CHKARG(p_dnmix_buf);
    ERR_CHKARG(p_delaybuf);
    ERR_CHKARG(p_working_buf);

    /* window downmixed data */
    p_dnmix1 = p_dnmix_buf + (3 * GBL_BLKSIZE / 4);
    p_dnmix2 = p_dnmix_buf + (GBL_BLKSIZE / 4 - 1);
    p_delay1 = p_delaybuf;
    p_delay2 = p_delaybuf + (GBL_BLKSIZE / 2 - 1);
    p_wind1 = window;
    p_wind2 = window + (GBL_BLKSIZE - 1);
    p_pcm1 = p_working_buf;
    p_pcm2 = p_working_buf + (GBL_BLKSIZE - 1);

    /* perform window overlap/add */
    for (i = 0; i < GBL_BLKSIZE/4; i++)
    {
        delayXwin = DLB_mpy32x32(DLB_sneg32(*p_delay1), (*p_wind2));
        dnmixXwin = DLB_mpy32x32((*p_dnmix1), (*p_wind1));
        samp = DLB_ssub(delayXwin, dnmixXwin);
        samp = DLB_mpy32x32(samp, GBL_PERCENT2FRACT_MAP(scalefactor));
        samp = DLB_sshl(samp, 1);
        *p_pcm1++ = samp;

        delayXwin = DLB_mpy32x32(DLB_sneg32(*p_delay1++), (*p_wind1++));
        dnmixXwin = DLB_mpy32x32((*p_dnmix1++), (*p_wind2--));
        samp = DLB_sadd(delayXwin, dnmixXwin);
        samp = DLB_mpy32x32(samp, GBL_PERCENT2FRACT_MAP(scalefactor));
        samp = DLB_sshl(samp, 1);
        *p_pcm2-- = samp;

        delayXwin = DLB_mpy32x32((*p_delay2), (*p_wind2));
        dnmixXwin = DLB_mpy32x32((*p_dnmix2), (*p_wind1));
        samp = DLB_sadd(delayXwin, dnmixXwin);
        samp = DLB_mpy32x32(samp, GBL_PERCENT2FRACT_MAP(scalefactor));
        samp = DLB_sshl(samp, 1);
        *p_pcm1++ = samp;

        delayXwin = DLB_mpy32x32((*p_delay2--), (*p_wind1++));
        dnmixXwin = DLB_mpy32x32((*p_dnmix2--), (*p_wind2--));
        samp = DLB_ssub(delayXwin, dnmixXwin);
        samp = DLB_mpy32x32(samp, GBL_PERCENT2FRACT_MAP(scalefactor));
        samp = DLB_sshl(samp, 1);
        *p_pcm2-- = samp;
    }

    /* update delay buffers */
    p_dnmix1 = p_dnmix_buf + (GBL_BLKSIZE / 4);
    p_delay1 = p_delaybuf;
    for (i = 0; i < GBL_BLKSIZE/2; i++)
    {
        *p_delay1++ = *p_dnmix1++;
    }

#if defined(DEBUG)
    DBG_PRINTB4BHDR(p_dbg, "PCM samples", &p_dbg->dbgfile_pcm);
    for (i = 0; i < GBL_BLKSIZE; i++)
    {
        DBG_PRINTB4B(p_dbg, "\t\tpcmbuf[%03d] = ", &i, T_DSPSHORT, &p_dbg->dbgfile_pcm);
        DBG_PRINTB4B(p_dbg, "% 16.24lf\n", &p_working_buf[i], T_DSPFRACT, &p_dbg->dbgfile_pcm);
    }
#endif /* defined(DEBUG) */

    /* PCM pointers are NULL aware */
    if (p_pcmptrs != 0)
    {
        /* copy PCM samples to output buffer */
        p_pcm2 = p_pcmptrs->p_pcmbuf;
        offset = p_pcmptrs->chanoffset;
        for (i = 0; i < GBL_BLKSIZE; i++)
        {
            *p_pcm2 = *p_working_buf++;
            p_pcm2 += offset;
        }
    }

    return (0);
}

#endif
